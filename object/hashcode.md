# java.lang.Object#hashCode

## Введение

Вызов метода `hashCode()` у объекта вернет нам целое число типа `int`.

Этот метод - это реализация `hash`-функции для `Java`-объекта. Возвращаемое число в `Java` считается `hash`-кодом объекта.

Объявление метода выглядит так:

```java
 public native int hashCode();
```

> Ключевое слово `native` означает, что метод реализован в платформенно-зависимом коде, чаще всего на `C/C++`, и скомпонован в виде динамической библиотеки.
>
> Эта реализация зависит от `JVM`.

> Возможно, вас сейчас это напугало, но на самом деле достаточно просто понимать, что 
> `native` означает лишь то, что вызываемый код, реализован не на `Java`.

Модификатор `native` применим только к **методам**, но не к классам или переменным.

При этом, `native`-методы вполне можно переопределять в `Java` коде, о чем пойдет речь далее.

## Почему надо переопределять hashCode

В ассоциативных массивах(их еще называют словари, мапы) важность `hashCode`-а нельзя  недооценивать.

По сути, главное преимущество ассоциативных массивов основано на `hashCode`. И для его использования надо **обязательно** переопределять данный метод.

[Подробнее об этом](../collections/map/intro.md)

Так как этот метод принадлежит `java.lang.Object`, то все объекты в `Java` имеют некоторую стандартную `hash`-функцию.

Контракт `hashCode` предъявляет следующие требования к реализации метода:

* Если вызвать метод `hashCode` на одном и том же объекте, состояние которого не меняли, то мы **обязаны** получить одно и то же значение.
  
* Если два объекта равны, то вызов `hashCode` для каждого **обязан** давать один и тот же результат.
  
    > Равенство объектов проверяется через вызов метода `equals`.

* Если два объекта имеют один и тот же `hash`-код, то это не гарантирует равенства объектов.

Проще говоря, разный `hash`-код у двух объектов - это гарантия того, что объекты не равны, в то время как одинаковый `hash`-код не гарантирует равенства.

Такая ситуация, когда разные объекты имеют одинаковые `hash`-код, называется `collision` или коллизией.

> Логично, что коллизии возможны - так как размер `int` ограничен.

По умолчанию, метод `hashCode` возвращает разные значения `hash`-кодов для разных объектов.
Например:

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(new A(4).hashCode());
        System.out.println(new A(4).hashCode());
    }
}

class A {
    private int a;

    public A(int a) {
        this.a = a;
    }
}
```

Получим два разных значния.

> Это связано с тем, что `native` реализация метода `hashCode()` возвращает преобразование внутреннего адреса объекта в `int`.
> Просто запомните, что `native` реализация для разных объетов возвращает разные значения `hash`-кодов, не взирая на состояние объекта.

Вообще надо понимать, что `hashCode`, наряду с `equals`, играет важную роль в сравнении объектов.
По сути он показывает изменилась ли информация, которую мы используем в `equals` для сравнения объектов.

Именно поэтому, если вы переопределяете `equals` - вы *обязаны* переопределить `hashCode`.

## Переопределение hashCode

Самый очевидный и самый плохой пример как можно переопределить `hashCode` - это всегда возвращать какое-то одно число.

```java
@Override
public int hashCode() {
return 14;
}
```

Для равных объектов такой метод вернет одно и то же число, что удовлетворяет спецификации.

Это валидная реализация, отвечающая требованиям, но использовать такой подход - значит лишать себя всех преимуществ, которые дает нам использование `hash`-кода.
Например, `hash`-таблиц, так как при такой реализации у нас будут коллизии **всегда**.

[Почему это плохо для `hash`-таблиц](./collections/map/)

Теперь, когда мы решили, что возвращать всегда одно и то же - плохое решение, давайте поговорим о том, что нужно включать в рассчет `hashCode`.

Необходимо исключить избыточные поля, которые не участвуют в `equals`.

Далее, необходимо выбрать базу - число, которое будет основной вычисления `hash`-кода.

По историческим причинам обычно за базу берут число `31`.
Кто-то говорит, что это взято из-за близости к числу `32`, т.е степени двойки `2^5 - 1`.
Кто-то утвеждает, что был проведен эксперимент и наиболее лучшей базой получились числа `31` и `33`, а `31` понравилось больше.

В целом, вы можете выбрать за базу что хотите, но принято выбирать `31`.
Многие `IDE` генерят `hashCode` именно с такой базой.

Правила вычисления `hashCode`:

* Присваиваем переменной result ненулевое значение - базу.
* Далее для каждого значимого поля в объекте вычисляем `hashCode`, по следующим правилам:

    1.Если поле `boolean` - `(f ? 1 : 0)`

    2.Если поле `byte`, `char`, `short` или `int` - `(int)f`

    3.Если поле `long` - `(int)(f ^ (f >>> 32))`

    4.Если поле `float`, то `Float.floatToIntBits(f);`

    5.Если поле `double`, то `Double.doubleToLongBits(f)`, а затем как с `long`.

    6.Если поле это ссылка на другой объект, то рекурсивно вызовите `hashCode()`

    7.Если поле `null` - то возвращаем `0`.

    8.Если поле это массив - то обрабатываем так, как будто каждый элемент массива - это поле объекта.

* После каждого обработанного поля объединяем его `hashCode` с текущим значением:
  
    ```java
    result = 31 * result + c; //c - это hashCode обработанного поля.
    ```
* Возвращаем результат.

Пример:

```java
public class Person {
    private int age;
    private int number;
    private double salary;
    private String name;
    private CarKey carKey;

    public Person(int age, int number, String name, double salary, CarKey carKey) {
        this.age = age;
        this.number = number;
        this.name = name;
        this.salary = salary;
        this.carKey = carKey;
    }

    @Override
    public int hashCode() {
      int result = 31;
      result = result * 17 + age;
      result = result * 17 + number;

      long lnum = Double.doubleToLongBits(number);
      result = result * 17 + (int)(lnum ^ (lnum >>> 32));

      result = result * 17 + name.hashCode();
      result = result * 17 + carKey.hashCode();

      return result;
    }

    // override equals
}
```

## Надо знать

Еще надо помнить, что типы обертки возвращают в качестве `hashCode` свое значение.
Продемонстрируем:

```java
public class Test {
    public static void main(String[] args) {
        Integer a = 5000;
        System.out.println(a.hashCode());
    }
}
```

Выведет нам `5000`.

## Заключение

* Если вы переопределяете `equals` - переопределяйте и `hashCode`.
* Обертки над примитивными типами возвращают в качестве `hash`-кода свое значение.
* Помните, что плохая реализация `hash`-функции даст вам большое количество коллизий, что сведет на нет все преимущества использования `hash`-функций.

> Помните, что большинство IDE сейчас легко сгенерируют вам `hashCode`, чтобы вы не писали его вручную.
>
> Также, существуют сторонние проекты, которые берут кодогенерацию на себя, например, проект [lombok](https://projectlombok.org/).
